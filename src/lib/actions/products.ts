
"use server";

import { z } from 'zod';
import { ProductSchema } from '@/lib/schemas';
import { revalidatePath } from 'next/cache';
import { prisma } from '@/lib/db'; // Use Prisma client
import type { Product } from '@/types'; // Assuming Product type is compatible

export async function createProduct(values: z.infer<typeof ProductSchema>) {
  const validatedFields = ProductSchema.safeParse(values);

  if (!validatedFields.success) {
    return { error: "Invalid fields!", fieldErrors: validatedFields.error.flatten().fieldErrors };
  }

  // ID is now auto-generated by Prisma if not provided
  const { name, price, cost, quantity } = validatedFields.data;
  
  try {
    const newProduct = await prisma.product.create({
      data: {
        name,
        price,
        cost,
        quantity,
      },
    });

    revalidatePath('/app/products');
    return { success: "Product created successfully!", product: newProduct };
  } catch (error) {
    console.error("Prisma Error (createProduct):", error);
    return { error: "Failed to create product in database." };
  }
}

export async function updateProduct(id: string, values: z.infer<typeof ProductSchema>) {
  const validatedFields = ProductSchema.safeParse(values);

  if (!validatedFields.success) {
    return { error: "Invalid fields!", fieldErrors: validatedFields.error.flatten().fieldErrors };
  }

  const { name, price, cost, quantity } = validatedFields.data;

  try {
    const updatedProduct = await prisma.product.update({
      where: { id },
      data: {
        name,
        price,
        cost,
        quantity,
        // updatedAt is handled by Prisma's @updatedAt
      },
    });

    revalidatePath('/app/products');
    revalidatePath(`/app/dashboard`); // Low stock items might change
    return { success: "Product updated successfully!", product: updatedProduct };
  } catch (error) {
    console.error("Prisma Error (updateProduct):", error);
    // Check for Prisma P2025 error (Record to update not found)
    if ((error as any).code === 'P2025') {
        return { error: "Product not found!" };
    }
    return { error: "Failed to update product in database." };
  }
}

export async function deleteProduct(id: string) {
  try {
    // Prisma will enforce the `onDelete: Restrict` rule from the schema for SaleItem.
    // This means if a product is part of any SaleItem, deletion will fail.
    // First, check for associated sale items.
    const associatedSales = await prisma.saleItem.count({
      where: { productId: id },
    });

    if (associatedSales > 0) {
      return { error: "Cannot delete product: It has associated sales records. Consider archiving the product instead." };
    }
    
    await prisma.product.delete({
      where: { id },
    });

    revalidatePath('/app/products');
    revalidatePath('/app/dashboard');
    return { success: "Product deleted successfully!" };
  } catch (error) {
    console.error("Prisma Error (deleteProduct):", error);
     // Check for Prisma P2025 error (Record to delete not found)
    if ((error as any).code === 'P2025') {
        return { error: "Product not found!" };
    }
    // Prisma's default behavior for foreign key constraints (like P2003 for pg)
    // will be caught if the above check for associatedSales is bypassed or fails.
    // The `onDelete: Restrict` in schema.prisma for SaleItem->Product relation
    // should prevent deletion if saleItems exist for this product.
    if ((error as any).code === 'P2003' || (error as any).code === 'P2014') { // Foreign key constraint failed
        return { error: "Cannot delete product: It is referenced in existing sales records or other relations." };
    }
    return { error: "Failed to delete product from database." };
  }
}
